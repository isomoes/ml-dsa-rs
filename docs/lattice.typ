#import "@preview/basic-document-props:0.1.0": simple-page
#import "@preview/cetz:0.3.4": canvas, draw

#show: simple-page.with(
  "isomo",
  "",
  middle-text: "lattice intro",
  date: true,
  numbering: true,
  supress-mail-link: false,
)

#set heading(numbering: "1.1")
#set math.equation(numbering: "(1)")
#set text(size: 11pt, lang: "en")
#show table: it => align(center, it)

= Lattice Geometry for ML-DSA (Intuition First)

This note explains lattice geometry without heavy formulas first, then connects it to the short-vector problems used in lattice cryptography.

== What is a lattice?

*Everyday analogy.* Imagine tiling a floor with parallelogram-shaped tiles. The corners of every tile form a regular, infinite pattern — that pattern is a lattice. You pick a starting point (the origin) and two "step" directions; every point you can reach by taking whole-number steps along those directions is a lattice point.

More precisely, given $m$ linearly independent vectors $bold(b)_1, bold(b)_2, dots, bold(b)_m in RR^n$, the lattice they generate is:

$
  cal(L)(B) = { z_1 bold(b)_1 + z_2 bold(b)_2 + dots.c + z_m bold(b)_m : z_i in ZZ } = { B bold(z) : bold(z) in ZZ^m }
$ <lattice-def>

where $B = [bold(b)_1 | bold(b)_2 | dots.c | bold(b)_m]$ is the *basis matrix* (columns are basis vectors).

Key properties:
- *Discrete*: lattice points are isolated — there is a minimum distance between any two distinct points.
- *Periodic*: the pattern repeats in every basis direction.
- *Rank $m$, dimension $n$*: the lattice lives in $RR^n$ but is spanned by $m$ vectors. When $m = n$ the lattice is called *full-rank*.

#figure(
  caption: [A 2D lattice generated by $bold(b)_1$ and $bold(b)_2$. Every dot is an integer combination $z_1 bold(b)_1 + z_2 bold(b)_2$. The shaded region is the *fundamental parallelogram* — it tiles the plane with no gaps or overlaps.],
  canvas(length: 0.8cm, {
    import draw: *

    // Draw the fundamental parallelogram (shaded)
    line((0, 0), (1.8, 0.0), (2.7, 1.4), (0.9, 1.4), close: true, fill: rgb("#DBEAFE"), stroke: (
      paint: rgb("#93C5FD"),
      thickness: 0.6pt,
      dash: "dashed",
    ))

    // Draw lattice points
    for ix in range(-3, 5) {
      for iy in range(-3, 4) {
        let px = ix * 0.9 + iy * 0.9
        let py = iy * 1.4
        if px >= -3.5 and px <= 4.5 and py >= -3.5 and py <= 4.0 {
          circle((px, py), radius: 0.05, fill: rgb("#6B7280"))
        }
      }
    }

    // Basis vectors (thick arrows)
    set-style(mark: (end: ">", size: 0.15))
    line((0, 0), (1.8, 0.0), stroke: (paint: rgb("#2563EB"), thickness: 1.6pt), name: "b1")
    line((0, 0), (0.9, 1.4), stroke: (paint: rgb("#DC2626"), thickness: 1.6pt), name: "b2")

    // Labels
    content((1.9, -0.25), text(fill: rgb("#2563EB"), weight: "bold")[$bold(b)_1$])
    content((0.55, 1.55), text(fill: rgb("#DC2626"), weight: "bold")[$bold(b)_2$])
    content((-0.2, -0.2), text(weight: "bold")[$bold(0)$])

    // Annotate a sample point
    circle((2.7, 1.4), radius: 0.08, fill: rgb("#F59E0B"))
    content((3.3, 1.55), text(size: 9pt, fill: rgb("#B45309"))[$bold(b)_1 + bold(b)_2$])
  }),
)

*Example in $ZZ^2$.* Take $bold(b)_1 = (2, 0)$ and $bold(b)_2 = (1, 3)$. Then:
- $1 dot bold(b)_1 + 1 dot bold(b)_2 = (3, 3)$ ✓ lattice point
- $(1.5, 1.5)$ is *not* a lattice point — no integer combination produces it.

== Same lattice, different bases

A single lattice can be described by many different bases. Two bases $B$ and $B'$ generate the same lattice if and only if $B' = B U$ where $U$ is a *unimodular matrix* (integer matrix with $det(U) = plus.minus 1$).

$ cal(L)(B) = cal(L)(B') quad <==> quad B' = B U, quad U in ZZ^(m times m), quad det(U) = plus.minus 1 $ <basis-equiv>

Why this matters for cryptography:

- A *good basis* has short, nearly orthogonal vectors — problems like finding short vectors are easy.
- A *bad basis* has long, highly skewed vectors — the same problems become computationally hard.

Lattice cryptography works by publishing a bad basis (or equivalent public information) while keeping a good basis secret.

#figure(
  caption: [Two bases for the *same* lattice. Left: short, nearly orthogonal (good). Right: long, skewed (bad). The lattice points are identical.],
  canvas(length: 0.7cm, {
    import draw: *

    // === Good basis (left) ===
    // Draw lattice points for good basis
    for ix in range(-3, 5) {
      for iy in range(-3, 5) {
        let px = ix * 1.0 + iy * 0.2
        let py = iy * 1.0
        if px >= -2.5 and px <= 4.0 and py >= -2.5 and py <= 3.5 {
          circle((px - 5.0, py), radius: 0.05, fill: rgb("#6B7280"))
        }
      }
    }

    // Good basis vectors
    set-style(mark: (end: ">", size: 0.12))
    line((-5.0, 0), (-4.0, 0), stroke: (paint: rgb("#059669"), thickness: 1.6pt))
    line((-5.0, 0), (-4.8, 1.0), stroke: (paint: rgb("#059669"), thickness: 1.6pt))
    content((-3.7, -0.25), text(size: 9pt, fill: rgb("#059669"))[$bold(b)_1$])
    content((-4.5, 1.15), text(size: 9pt, fill: rgb("#059669"))[$bold(b)_2$])
    content((-3.5, -1.8), text(size: 9pt, weight: "bold")[Good basis])

    // === Bad basis (right) ===
    // Same lattice, different basis
    for ix in range(-3, 5) {
      for iy in range(-3, 5) {
        let px = ix * 1.0 + iy * 0.2
        let py = iy * 1.0
        if px >= -2.5 and px <= 4.0 and py >= -2.5 and py <= 3.5 {
          circle((px + 2.0, py), radius: 0.05, fill: rgb("#6B7280"))
        }
      }
    }

    // Bad basis vectors (long, skewed)
    line((2.0, 0), (5.2, 2.0), stroke: (paint: rgb("#DC2626"), thickness: 1.6pt))
    line((2.0, 0), (4.4, 3.0), stroke: (paint: rgb("#DC2626"), thickness: 1.6pt))
    content((5.5, 2.0), text(size: 9pt, fill: rgb("#DC2626"))[$bold(b)'_1$])
    content((4.7, 3.15), text(size: 9pt, fill: rgb("#DC2626"))[$bold(b)'_2$])
    content((3.5, -1.8), text(size: 9pt, weight: "bold")[Bad basis])
  }),
)

== Short vectors and the SVP

The *minimum distance* of a lattice is the length of its shortest nonzero vector:

$ lambda_1(cal(L)) = min_(bold(v) in cal(L) \\ {bold(0)}) norm(bold(v))_2 $ <lambda1>

#strong[Shortest Vector Problem (SVP).] Given a basis $B$ of lattice $cal(L)$, find a nonzero $bold(v) in cal(L)$ such that $norm(bold(v))_2 = lambda_1(cal(L))$.

In practice, even the *approximate* version is hard:

#strong[Approximate SVP ($"SVP"_gamma$).] Find nonzero $bold(v) in cal(L)$ with $norm(bold(v))_2 <= gamma dot lambda_1(cal(L))$.

#figure(
  caption: [SVP intuition. The origin is the black dot; the green arrow is the shortest nonzero lattice vector. The dashed circle has radius $lambda_1$ — no lattice point (except the origin) lies inside it.],
  canvas(length: 0.8cm, {
    import draw: *

    // Lattice points
    for x in range(-4, 5) {
      for y in range(-4, 5) {
        let px = x * 0.9
        let py = y * 0.9
        if px >= -3.2 and px <= 3.2 and py >= -3.2 and py <= 3.2 {
          circle((px, py), radius: 0.04, fill: rgb("#9CA3AF"))
        }
      }
    }

    // Origin
    circle((0, 0), radius: 0.08, fill: rgb("#111827"))

    // lambda_1 circle (dashed)
    circle((0, 0), radius: 0.9, stroke: (paint: rgb("#F59E0B"), thickness: 1pt, dash: "dashed"))
    content((0.3, 0.75), text(size: 8pt, fill: rgb("#B45309"))[$lambda_1$])

    // Shortest vector
    set-style(mark: (end: ">", size: 0.12))
    line((0, 0), (0.9, 0.0), stroke: (paint: rgb("#059669"), thickness: 2pt))
    content((0.95, -0.2), text(size: 9pt, fill: rgb("#059669"), weight: "bold")[shortest])

    // A longer vector for contrast
    line((0, 0), (1.8, 0.9), stroke: (paint: rgb("#9CA3AF"), thickness: 1pt, dash: "dotted"))
    content((2.1, 1.0), text(size: 8pt, fill: rgb("#6B7280"))[longer])
  }),
)

*Why SVP is hard:*

#table(
  columns: (auto, auto),
  align: (left, left),
  table.header([*Factor*], [*Explanation*]),
  [High dimension], [In dimension $n >= 500$, the number of candidate directions grows exponentially.],
  [Exponential search space], [Integer combinations $B bold(z)$ for $bold(z) in ZZ^m$ form an infinite discrete set.],
  [Best algorithms are slow], [The fastest known exact SVP algorithm runs in $2^(O(n))$ time and space.],
  [No quantum speedup], [Unlike factoring, no efficient quantum algorithm for SVP is known.],
)

== Closest Vector Problem (CVP)

The CVP is the "sister problem" of SVP and is directly relevant to signatures.

#strong[CVP.] Given a basis $B$ of lattice $cal(L)$ and a target point $bold(t) in RR^n$ (not necessarily on the lattice), find the lattice point closest to $bold(t)$:

$ "find" quad bold(v)^* = arg min_(bold(v) in cal(L)) norm(bold(v) - bold(t))_2 $ <cvp>

*Connection to signatures:* In ML-DSA, signing essentially requires solving a bounded-distance decoding problem — finding a lattice point within a certain radius of a target derived from the message hash. The signer can do this efficiently using the secret key (a good basis / trapdoor), while an attacker without the secret key faces a hard CVP instance.

#figure(
  caption: [CVP: find the lattice point (green) closest to the target $bold(t)$ (red cross). The dashed circle shows the distance to the nearest lattice point.],
  canvas(length: 0.8cm, {
    import draw: *

    // Lattice points
    for x in range(-4, 5) {
      for y in range(-4, 5) {
        let px = x * 1.0
        let py = y * 1.0
        if px >= -3.5 and px <= 3.5 and py >= -3.5 and py <= 3.5 {
          circle((px, py), radius: 0.04, fill: rgb("#9CA3AF"))
        }
      }
    }

    // Target point (off-lattice)
    let tx = 1.3
    let ty = 0.7

    // Closest lattice point
    circle((1.0, 1.0), radius: 0.08, fill: rgb("#059669"))
    content((1.3, 1.2), text(size: 9pt, fill: rgb("#059669"), weight: "bold")[$bold(v)^*$])

    // Distance circle
    let dx = tx - 1.0
    let dy = ty - 1.0
    circle((tx, ty), radius: 0.42, stroke: (paint: rgb("#F59E0B"), thickness: 0.8pt, dash: "dashed"))

    // Target
    line((tx - 0.1, ty - 0.1), (tx + 0.1, ty + 0.1), stroke: (paint: rgb("#DC2626"), thickness: 1.5pt))
    line((tx - 0.1, ty + 0.1), (tx + 0.1, ty - 0.1), stroke: (paint: rgb("#DC2626"), thickness: 1.5pt))
    content((tx + 0.3, ty - 0.2), text(size: 9pt, fill: rgb("#DC2626"), weight: "bold")[$bold(t)$])

    // Arrow from target to closest
    set-style(mark: (end: ">", size: 0.1))
    line((tx, ty), (1.02, 0.98), stroke: (paint: rgb("#059669"), thickness: 1.2pt, dash: "dotted"))
  }),
)

== Short Integer Solutions (SIS)

Many lattice schemes (including ML-DSA verification) rely on the SIS problem.

#strong[SIS Problem.] Given a random matrix $bold(A) in ZZ_q^(n times m)$ (with $m > n$), find a nonzero *short* vector $bold(x) in ZZ^m$ such that:

$ bold(A) bold(x) = bold(0) mod q, quad norm(bold(x))_infinity <= beta $ <sis>

The kernel ${ bold(x) : bold(A) bold(x) = bold(0) mod q }$ is a lattice. SIS asks: find a *short* vector in this lattice.

*Why SIS is hard:*
- Solutions exist (the kernel is a lattice of dimension $m - n$, so it has many vectors).
- *Short* solutions are rare — a random kernel vector has entries of order $q$, not $beta$.
- Finding the short ones is as hard as worst-case lattice problems (Ajtai's theorem).

*Geometric picture:*

#figure(
  caption: [SIS geometry. The grey plane is the solution space $bold(A) bold(x) = bold(0)$. Lattice points on this plane are plentiful, but only a few (green) are short — close to the origin.],
  canvas(length: 0.8cm, {
    import draw: *

    // Draw the "solution hyperplane" as a tilted band
    line((-3.5, -1.5), (3.5, 1.5), stroke: (paint: rgb("#D1D5DB"), thickness: 8pt))

    // Lattice points on the plane (spread out)
    for i in range(-3, 4) {
      let px = i * 1.0
      let py = i * 0.43
      circle((px, py), radius: 0.05, fill: rgb("#9CA3AF"))
    }

    // Origin
    circle((0, 0), radius: 0.08, fill: rgb("#111827"))
    content((-0.3, -0.3), text(size: 9pt)[$bold(0)$])

    // Short solution (close to origin)
    circle((1.0, 0.43), radius: 0.08, fill: rgb("#059669"))
    content((1.3, 0.65), text(size: 9pt, fill: rgb("#059669"), weight: "bold")[short $bold(x)$])

    // Long solution (far from origin)
    circle((3.0, 1.29), radius: 0.06, fill: rgb("#DC2626"))
    content((3.3, 1.5), text(size: 8pt, fill: rgb("#DC2626"))[long $bold(x)$])

    // Beta ball
    circle((0, 0), radius: 1.2, stroke: (paint: rgb("#F59E0B"), thickness: 0.8pt, dash: "dashed"))
    content((0.9, -0.9), text(size: 8pt, fill: rgb("#B45309"))[$norm(bold(x)) <= beta$])
  }),
)

*Toy example* over $q = 17$:

$ bold(A) = mat(3, 5, 7) $

We need $3x_1 + 5x_2 + 7x_3 equiv 0 mod 17$ with small $x_i$.

- $bold(x) = (1, 2, 3)$: check $3 + 10 + 21 = 34 equiv 0 mod 17$ ✓, and $norm(bold(x))_infinity = 3$ (short!).
- $bold(x) = (0, 10, 5)$: also satisfies the equation, but $norm(bold(x))_infinity = 10$ (not short).

== Learning With Errors (LWE) — the dual view

While SIS asks "find short $bold(x)$ with $bold(A) bold(x) = bold(0)$", the LWE problem goes the other direction:

#strong[LWE Problem.] Given $bold(A) in ZZ_q^(n times m)$ and $bold(b) = bold(A)^top bold(s) + bold(e) mod q$ where $bold(s)$ is secret and $bold(e)$ is a *short* error vector, recover $bold(s)$.

$ bold(b) = bold(A)^top bold(s) + bold(e) mod q $ <lwe>

The point $bold(b)$ is *close to* the lattice generated by $bold(A)^top$ — it is a lattice point plus small noise. So LWE is essentially a CVP instance.

#table(
  columns: (auto, auto, auto),
  align: (center, center, center),
  table.header([*Problem*], [*Given*], [*Find*]),
  [SIS], [$bold(A)$], [short $bold(x)$: $bold(A) bold(x) = bold(0)$],
  [LWE], [$bold(A), bold(b) = bold(A)^top bold(s) + bold(e)$], [secret $bold(s)$ (or distinguish from random)],
  [SVP], [basis $B$], [shortest nonzero $bold(v) in cal(L)(B)$],
  [CVP], [basis $B$, target $bold(t)$], [closest $bold(v) in cal(L)(B)$ to $bold(t)$],
)

== Module lattices (ML-DSA view)

ML-DSA does not use plain integer lattices — it uses *module lattices* over a polynomial ring. This gives both structure (for efficiency) and hardness (from the underlying lattice problems).

*The ring:*

$ R_q = ZZ_q [X] \/ (X^n + 1), quad n = 256, quad q = 8380417 $ <ring>

Each element of $R_q$ is a polynomial of degree $< 256$ with coefficients in $ZZ_q$. Addition and multiplication follow polynomial arithmetic modulo $X^{256} + 1$.

*From ring to module:* A module vector $bold(v) in R_q^k$ has $k$ polynomial entries, each with 256 coefficients. So $bold(v)$ corresponds to $256 k$ integers — a point in a high-dimensional lattice.

#figure(
  caption: [Module-lattice structure: each polynomial block contributes 256 coefficients, so a vector in $R_q^k$ maps to a point in dimension $256 k$.],
  canvas(length: 1.0cm, {
    import draw: *

    // Module vector blocks
    for i in range(0, 4) {
      let x = i * 1.8
      rect((x, 0), (x + 1.5, 0.8), stroke: rgb("#2563EB"), radius: 0.06, fill: rgb("#EFF6FF"))
      content((x + 0.75, 0.4), text(size: 9pt)[$f_#(i + 1) in R_q$])
    }

    // Brace label
    content((3.45, 1.15), text(size: 9pt, fill: rgb("#2563EB"), weight: "bold")[$bold(v) in R_q^4$])

    // Arrow down
    set-style(mark: (end: ">", size: 0.12))
    line((3.45, -0.15), (3.45, -0.7), stroke: (paint: rgb("#6B7280"), thickness: 1pt))
    content((3.45, -0.45), anchor: "west", dx: 0.15, text(size: 8pt, fill: rgb("#6B7280"))[flatten])

    // Coefficient vector
    rect((-0.3, -1.5), (7.2, -0.85), stroke: rgb("#DC2626"), radius: 0.06, fill: rgb("#FEF2F2"))
    content((3.45, -1.18), text(size: 9pt)[$( a_0, a_1, dots, a_(1023) ) in ZZ_q^(1024)$])
    content((3.45, -1.85), text(size: 8pt, fill: rgb("#DC2626"), weight: "bold")[dimension $= 256 times 4 = 1024$])
  }),
)

*Why modules?*

#table(
  columns: (auto, auto),
  align: (left, left),
  table.header([*Benefit*], [*Explanation*]),
  [Fast arithmetic], [Polynomial multiplication via NTT in $O(n log n)$ instead of $O(n^2)$.],
  [Compact keys],
  [A $k times l$ matrix over $R_q$ stores $256 k l$ coefficients, but behaves like a $256k times 256l$ integer matrix.],

  [Tunable security], [Increase $k$ (module rank) to raise the lattice dimension without changing the ring.],
  [Worst-case hardness],
  [Module-SIS and Module-LWE reduce to worst-case lattice problems (under standard assumptions).],
)

*ML-DSA parameter sets:*

#table(
  columns: (auto, auto, auto, auto, auto),
  align: (center, center, center, center, center),
  table.header([*Variant*], [$(k, l)$], [*Lattice dim*], [*Security*], [*NIST level*]),
  [ML-DSA-44], [$(4, 4)$], [$256 times 4 = 1024$], [~128 bit], [2],
  [ML-DSA-65], [$(6, 5)$], [$256 times 6 = 1536$], [~192 bit], [3],
  [ML-DSA-87], [$(8, 7)$], [$256 times 8 = 2048$], [~256 bit], [5],
)

== How ML-DSA uses these ideas

ML-DSA is a *Fiat-Shamir with Aborts* signature scheme built on Module-LWE and Module-SIS. This section walks through every phase with figures.

=== Big picture

#figure(
  caption: [ML-DSA lifecycle. Three phases share the public matrix $bold(A)$. The secret key enables efficient signing; the public key enables verification. The signature $(tilde(c), bold(z), bold(h))$ is short — this is the lattice constraint.],
  canvas(length: 0.75cm, {
    import draw: *

    // ── Seed ──
    rect((4.0, 5.8), (7.0, 6.5), stroke: rgb("#6B7280"), radius: 0.08, fill: rgb("#F3F4F6"))
    content((5.5, 6.15), text(size: 8pt, weight: "bold")[seed $xi in {0,1}^(256)$])

    set-style(mark: (end: ">", size: 0.1))
    line((5.5, 5.75), (5.5, 5.25), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt))

    // ── KeyGen ──
    rect((2.5, 3.8), (8.5, 5.25), stroke: rgb("#2563EB"), radius: 0.1, fill: rgb("#EFF6FF"))
    content((5.5, 4.95), text(size: 9pt, fill: rgb("#2563EB"), weight: "bold")[KeyGen (Algorithm 1)])
    content((5.5, 4.55), text(size: 7.5pt)[$rho, rho', K = H(xi)$])
    content((5.5, 4.2), text(size: 7.5pt)[$bold(A) = "ExpandA"(rho), quad bold(s)_1, bold(s)_2 = "ExpandS"(rho')$])
    content((5.5, 3.9), text(size: 7.5pt)[$bold(t) = bold(A) bold(s)_1 + bold(s)_2$])

    // outputs
    line((3.5, 3.75), (3.5, 3.0), stroke: (paint: rgb("#2563EB"), thickness: 0.8pt))
    line((7.5, 3.75), (7.5, 3.0), stroke: (paint: rgb("#2563EB"), thickness: 0.8pt))

    // ── SK box ──
    rect((1.5, 2.2), (5.5, 3.0), stroke: rgb("#059669"), radius: 0.08, fill: rgb("#ECFDF5"))
    content((3.5, 2.7), text(size: 8pt, fill: rgb("#059669"), weight: "bold")[Secret Key])
    content((3.5, 2.35), text(size: 7pt)[$"sk" = (rho, K, "tr", bold(s)_1, bold(s)_2, bold(t)_0)$])

    // ── PK box ──
    rect((5.8, 2.2), (9.5, 3.0), stroke: rgb("#7C3AED"), radius: 0.08, fill: rgb("#F5F3FF"))
    content((7.65, 2.7), text(size: 8pt, fill: rgb("#7C3AED"), weight: "bold")[Public Key])
    content((7.65, 2.35), text(size: 7pt)[$"pk" = (rho, bold(t)_1)$])

    // ── Sign ──
    line((3.5, 2.15), (3.5, 1.5), stroke: (paint: rgb("#059669"), thickness: 0.8pt))
    rect((0.5, -0.8), (6.5, 1.5), stroke: rgb("#059669"), radius: 0.1, fill: rgb("#F0FDF4"))
    content((3.5, 1.2), text(size: 9pt, fill: rgb("#059669"), weight: "bold")[Sign (Algorithm 2)])
    content((3.5, 0.8), text(size: 7.5pt)[$bold(y) arrow.l "ExpandMask"(rho'', kappa)$])
    content((3.5, 0.45), text(size: 7.5pt)[$bold(w) = bold(A) bold(y), quad tilde(c) = H(mu || bold(w)_1)$])
    content((3.5, 0.1), text(size: 7.5pt)[$c = "SampleInBall"(tilde(c)), quad bold(z) = bold(y) + c bold(s)_1$])
    content((3.5, -0.25), text(
      size: 7.5pt,
      fill: rgb("#DC2626"),
    )[if $norm(bold(z))_infinity >= gamma_1 - beta$ or hints fail: *restart*])
    content((3.5, -0.6), text(size: 7.5pt)[$sigma = (tilde(c), bold(z), bold(h))$])

    // rejection loop
    bezier((6.6, 0.1), (6.6, 1.6), (7.4, 0.1), (7.4, 1.6), stroke: (
      paint: rgb("#DC2626"),
      thickness: 0.7pt,
      dash: "dashed",
    ))
    line((6.6, 1.6), (5.8, 1.6), stroke: (paint: rgb("#DC2626"), thickness: 0.7pt, dash: "dashed"))
    content((7.8, 0.85), text(size: 6.5pt, fill: rgb("#DC2626"))[abort &\ retry])

    // ── Verify ──
    line((7.65, 2.15), (7.65, 1.5), stroke: (paint: rgb("#7C3AED"), thickness: 0.8pt))
    rect((8.0, -0.8), (14.0, 1.5), stroke: rgb("#7C3AED"), radius: 0.1, fill: rgb("#FAF5FF"))
    content((11.0, 1.2), text(size: 9pt, fill: rgb("#7C3AED"), weight: "bold")[Verify (Algorithm 3)])
    content((11.0, 0.8), text(size: 7.5pt)[$bold(A) = "ExpandA"(rho)$])
    content((11.0, 0.45), text(size: 7.5pt)[$bold(w)'_1 = "UseHint"(bold(h), bold(A) bold(z) - c bold(t))$])
    content((11.0, 0.1), text(size: 7.5pt)[$"check:" norm(bold(z))_infinity < gamma_1 - beta$])
    content((11.0, -0.25), text(size: 7.5pt)[$"check:" tilde(c) =^? H(mu || bold(w)'_1)$])
    content((11.0, -0.6), text(size: 7.5pt, fill: rgb("#059669"), weight: "bold")[accept / reject])

    // signature arrow from sign to verify
    line((6.6, -0.15), (7.9, -0.15), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt))
    content((7.25, 0.05), text(size: 6.5pt, fill: rgb("#6B7280"))[$sigma$])
  }),
)

=== Phase 1: Key Generation

Key generation creates a Module-LWE instance. The public key hides the short secrets.

*Step by step (FIPS 204, Algorithm 1 / Algorithm 6):*

+ Hash the 256-bit seed $xi$ to get three sub-seeds: $rho$ (for $bold(A)$), $rho'$ (for secrets), $K$ (for signing randomness).
+ *Expand the public matrix*: $hat(bold(A)) = "ExpandA"(rho) in R_q^(k times l)$. This is deterministic — anyone with $rho$ can reconstruct $bold(A)$.
+ *Sample short secrets*: $bold(s)_1 in R_q^l$ and $bold(s)_2 in R_q^k$ from $"ExpandS"(rho')$. Each coefficient satisfies $|"coeff"| <= eta$ (where $eta in {2, 4}$ depending on the parameter set).
+ *Compute the public vector*: $bold(t) = bold(A) bold(s)_1 + bold(s)_2 in R_q^k$.
+ *Split $bold(t)$*: write $bold(t) = bold(t)_1 dot 2^d + bold(t)_0$ (Power2Round). Only $bold(t)_1$ goes into the public key; $bold(t)_0$ stays in the secret key.

$ "pk" = (rho, bold(t)_1), quad "sk" = (rho, K, "tr", bold(s)_1, bold(s)_2, bold(t)_0) $

where $"tr" = H("pk")$ is a hash of the public key used during signing.

#figure(
  caption: [Key generation data flow. The seed $xi$ fans out into three sub-seeds. The public matrix $bold(A)$ and short secrets $bold(s)_1, bold(s)_2$ combine into $bold(t)$, which is split into public $bold(t)_1$ and secret $bold(t)_0$.],
  canvas(length: 0.85cm, {
    import draw: *
    set-style(mark: (end: ">", size: 0.1))

    // Seed
    rect((4.5, 6.0), (7.5, 6.7), stroke: rgb("#111827"), radius: 0.08, fill: rgb("#F9FAFB"))
    content((6.0, 6.35), text(size: 8pt, weight: "bold")[$xi$ (256-bit seed)])

    // Hash
    line((6.0, 5.95), (6.0, 5.4), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt))
    rect((4.8, 4.9), (7.2, 5.4), stroke: rgb("#6B7280"), radius: 0.06, fill: rgb("#F3F4F6"))
    content((6.0, 5.15), text(size: 7.5pt)[$H(xi) arrow (rho, rho', K)$])

    // Fan out to three sub-seeds
    line((5.2, 4.85), (2.5, 4.2), stroke: (paint: rgb("#2563EB"), thickness: 0.8pt))
    line((6.0, 4.85), (6.0, 4.2), stroke: (paint: rgb("#DC2626"), thickness: 0.8pt))
    line((6.8, 4.85), (9.5, 4.2), stroke: (paint: rgb("#F59E0B"), thickness: 0.8pt))

    // rho -> A
    rect((1.0, 3.5), (4.0, 4.2), stroke: rgb("#2563EB"), radius: 0.06, fill: rgb("#EFF6FF"))
    content((2.5, 3.85), text(size: 7.5pt, fill: rgb("#2563EB"))[$rho arrow.r.double "ExpandA"$])
    line((2.5, 3.45), (2.5, 2.8), stroke: (paint: rgb("#2563EB"), thickness: 0.8pt))
    rect((1.0, 2.2), (4.0, 2.8), stroke: rgb("#2563EB"), radius: 0.06, fill: rgb("#DBEAFE"))
    content((2.5, 2.5), text(size: 8pt, fill: rgb("#2563EB"), weight: "bold")[$hat(bold(A)) in R_q^(k times l)$])

    // rho' -> s1, s2
    rect((4.5, 3.5), (7.5, 4.2), stroke: rgb("#DC2626"), radius: 0.06, fill: rgb("#FEF2F2"))
    content((6.0, 3.85), text(size: 7.5pt, fill: rgb("#DC2626"))[$rho' arrow.r.double "ExpandS"$])
    line((5.3, 3.45), (5.0, 2.8), stroke: (paint: rgb("#DC2626"), thickness: 0.8pt))
    line((6.7, 3.45), (7.0, 2.8), stroke: (paint: rgb("#DC2626"), thickness: 0.8pt))
    rect((3.8, 2.2), (6.2, 2.8), stroke: rgb("#DC2626"), radius: 0.06, fill: rgb("#FEE2E2"))
    content((5.0, 2.5), text(size: 8pt, fill: rgb("#DC2626"), weight: "bold")[$bold(s)_1$ (short)])
    rect((6.0, 2.2), (8.2, 2.8), stroke: rgb("#DC2626"), radius: 0.06, fill: rgb("#FEE2E2"))
    content((7.1, 2.5), text(size: 8pt, fill: rgb("#DC2626"), weight: "bold")[$bold(s)_2$ (short)])

    // K
    rect((8.5, 3.5), (10.5, 4.2), stroke: rgb("#F59E0B"), radius: 0.06, fill: rgb("#FFFBEB"))
    content((9.5, 3.85), text(size: 7.5pt, fill: rgb("#B45309"))[$K$ (signing key)])

    // t = A s1 + s2
    line((2.5, 2.15), (5.5, 1.4), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt, dash: "dotted"))
    line((5.0, 2.15), (5.5, 1.4), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt, dash: "dotted"))
    line((7.1, 2.15), (5.5, 1.4), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt, dash: "dotted"))
    rect((4.0, 0.8), (7.0, 1.4), stroke: rgb("#111827"), radius: 0.06, fill: rgb("#F9FAFB"))
    content((5.5, 1.1), text(size: 8pt, weight: "bold")[$bold(t) = bold(A) bold(s)_1 + bold(s)_2$])

    // Power2Round split
    line((5.5, 0.75), (5.5, 0.25), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt))
    content((6.5, 0.5), text(size: 6.5pt, fill: rgb("#6B7280"))[Power2Round])

    line((4.5, 0.2), (3.5, -0.4), stroke: (paint: rgb("#7C3AED"), thickness: 0.8pt))
    line((6.5, 0.2), (7.5, -0.4), stroke: (paint: rgb("#059669"), thickness: 0.8pt))

    rect((2.0, -1.0), (5.0, -0.4), stroke: rgb("#7C3AED"), radius: 0.06, fill: rgb("#F5F3FF"))
    content((3.5, -0.7), text(size: 8pt, fill: rgb("#7C3AED"), weight: "bold")[$bold(t)_1$ → public key])

    rect((6.0, -1.0), (9.0, -0.4), stroke: rgb("#059669"), radius: 0.06, fill: rgb("#ECFDF5"))
    content((7.5, -0.7), text(size: 8pt, fill: rgb("#059669"), weight: "bold")[$bold(t)_0$ → secret key])
  }),
)

*Geometric view — why the public key hides the secret:*

#figure(
  caption: [Module-LWE geometry. The lattice consists of all points $bold(A) bold(x)$ for $bold(x) in R_q^l$. The public key $bold(t)$ equals $bold(A) bold(s)_1$ (a lattice point) plus the short error $bold(s)_2$. Recovering $bold(s)_1$ means finding which lattice point is closest to $bold(t)$ — a hard CVP instance without the trapdoor.],
  canvas(length: 0.85cm, {
    import draw: *

    // Lattice points
    for x in range(-3, 6) {
      for y in range(-2, 5) {
        let px = x * 1.1 + y * 0.3
        let py = y * 1.1
        if px >= -2.8 and px <= 5.5 and py >= -1.8 and py <= 4.5 {
          circle((px, py), radius: 0.04, fill: rgb("#D1D5DB"))
        }
      }
    }

    // Origin
    circle((0, 0), radius: 0.07, fill: rgb("#111827"))
    content((-0.35, -0.2), text(size: 8pt, weight: "bold")[$bold(0)$])

    // A*s1 (exact lattice point)
    let asx = 2.2 + 0.3
    let asy = 1.1
    circle((asx, asy), radius: 0.08, fill: rgb("#2563EB"))
    content((asx + 0.4, asy + 0.25), text(size: 8pt, fill: rgb("#2563EB"), weight: "bold")[$bold(A) bold(s)_1$])

    // t = A*s1 + s2 (off-lattice)
    let tx = asx + 0.25
    let ty = asy - 0.3
    circle((tx, ty), radius: 0.1, fill: rgb("#DC2626"))
    content((tx + 0.45, ty - 0.15), text(size: 8pt, fill: rgb("#DC2626"), weight: "bold")[$bold(t)$])

    // s2 arrow
    set-style(mark: (end: ">", size: 0.08))
    line((asx + 0.02, asy - 0.02), (tx - 0.02, ty + 0.02), stroke: (paint: rgb("#F59E0B"), thickness: 1.4pt))
    content((asx + 0.55, asy - 0.35), text(size: 7pt, fill: rgb("#B45309"))[$bold(s)_2$])

    // Nearby lattice points that an attacker might confuse
    let n1x = 1.1 + 0.6
    let n1y = 2.2
    circle((n1x, n1y), radius: 0.06, fill: rgb("#9CA3AF"))
    content((n1x - 0.6, n1y + 0.2), text(size: 6.5pt, fill: rgb("#6B7280"))[other $bold(A) bold(x)$])

    let n2x = 3.3 + 0.3
    let n2y = 1.1
    circle((n2x, n2y), radius: 0.06, fill: rgb("#9CA3AF"))

    // Dashed circle around t showing CVP difficulty
    circle((tx, ty), radius: 0.55, stroke: (paint: rgb("#F59E0B"), thickness: 0.7pt, dash: "dashed"))

    // Label
    content((4.5, 4.2), text(
      size: 7.5pt,
      fill: rgb("#6B7280"),
    )[lattice $cal(L) = {bold(A) bold(x) : bold(x) in R_q^l}$])

    // Attacker annotation
    content((4.5, -1.5), text(
      size: 7.5pt,
      fill: rgb("#DC2626"),
    )[Attacker sees $bold(t)$ but cannot tell which $bold(A) bold(x)$ is closest])
    content((4.5, -1.9), text(size: 7.5pt, fill: rgb("#DC2626"))[(Module-LWE hardness)])
  }),
)

=== Phase 2: Signing

Signing is the most intricate phase. It is an interactive proof made non-interactive via the Fiat-Shamir transform, with an abort mechanism to prevent secret leakage.

*Step by step (FIPS 204, Algorithm 2 / Algorithm 7):*

+ Compute $mu = H("tr" || M)$ where $M$ is the message and $"tr" = H("pk")$.
+ Compute $rho'' = H(K || "rnd" || mu)$ — the per-signature randomness seed.
+ Initialize counter $kappa = 0$.
+ *Loop* (may repeat multiple times):
  + *Mask*: $bold(y) = "ExpandMask"(rho'', kappa) in R_q^l$ with $|"coeff"| < gamma_1$.
  + *Commit*: $bold(w) = bold(A) bold(y)$, then decompose $bold(w) = bold(w)_1 dot 2 gamma_2 + bold(w)_0$.
  + *Challenge*: $tilde(c) = H(mu || "Encode"(bold(w)_1))$, then $c = "SampleInBall"(tilde(c)) in R_q$ (a sparse polynomial with $tau$ nonzero $plus.minus 1$ coefficients).
  + *Response*: $bold(z) = bold(y) + c bold(s)_1$.
  + *Check 1*: if $norm(bold(z))_infinity >= gamma_1 - beta$, set $kappa arrow.l kappa + l$ and go to step 4.
  + *Check 2*: compute $bold(r)_0 = bold(w) - c bold(s)_2$, extract low bits. If $norm(bold(r)_0)_infinity >= gamma_2 - beta$, restart.
  + *Hints*: $bold(h) = "MakeHint"(bold(r)_0, bold(w))$. If the number of nonzero hints exceeds $omega$, restart.
  + *Output*: $sigma = (tilde(c), bold(z), bold(h))$.

#figure(
  caption: [Signing flowchart. The inner loop (dashed red border) may execute multiple times due to rejection sampling. Each restart uses a fresh mask $bold(y)$ via an incremented counter $kappa$.],
  canvas(length: 0.7cm, {
    import draw: *
    set-style(mark: (end: ">", size: 0.1))

    // Input
    rect((3.5, 10.0), (8.5, 10.7), stroke: rgb("#111827"), radius: 0.08, fill: rgb("#F9FAFB"))
    content((6.0, 10.35), text(size: 8pt)[message $M$, secret key sk])
    line((6.0, 9.95), (6.0, 9.45), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt))

    // mu computation
    rect((3.5, 8.9), (8.5, 9.45), stroke: rgb("#6B7280"), radius: 0.06, fill: rgb("#F3F4F6"))
    content((6.0, 9.17), text(size: 7.5pt)[$mu = H("tr" || M), quad rho'' = H(K || "rnd" || mu)$])
    line((6.0, 8.85), (6.0, 8.35), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt))

    // ── Rejection loop border ──
    rect((0.5, 1.2), (11.5, 8.35), stroke: (paint: rgb("#DC2626"), thickness: 1pt, dash: "dashed"), radius: 0.12)
    content((6.0, 8.1), text(size: 7pt, fill: rgb("#DC2626"), weight: "bold")[rejection loop (may repeat)])

    // Step 1: mask
    rect((3.0, 7.2), (9.0, 7.8), stroke: rgb("#2563EB"), radius: 0.06, fill: rgb("#EFF6FF"))
    content((6.0, 7.5), text(
      size: 7.5pt,
      fill: rgb("#2563EB"),
    )[① $bold(y) = "ExpandMask"(rho'', kappa)$, $quad |y_i| < gamma_1$])
    line((6.0, 7.15), (6.0, 6.65), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))

    // Step 2: commit
    rect((3.0, 6.05), (9.0, 6.65), stroke: rgb("#2563EB"), radius: 0.06, fill: rgb("#EFF6FF"))
    content((6.0, 6.35), text(
      size: 7.5pt,
      fill: rgb("#2563EB"),
    )[② $bold(w) = bold(A) bold(y)$, decompose $bold(w)_1 = "HighBits"(bold(w))$])
    line((6.0, 6.0), (6.0, 5.5), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))

    // Step 3: challenge
    rect((3.0, 4.9), (9.0, 5.5), stroke: rgb("#7C3AED"), radius: 0.06, fill: rgb("#F5F3FF"))
    content((6.0, 5.2), text(
      size: 7.5pt,
      fill: rgb("#7C3AED"),
    )[③ $tilde(c) = H(mu || bold(w)_1)$, $c = "SampleInBall"(tilde(c))$])
    line((6.0, 4.85), (6.0, 4.35), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))

    // Step 4: response
    rect((3.0, 3.75), (9.0, 4.35), stroke: rgb("#059669"), radius: 0.06, fill: rgb("#ECFDF5"))
    content((6.0, 4.05), text(size: 7.5pt, fill: rgb("#059669"))[④ $bold(z) = bold(y) + c bold(s)_1$])
    line((6.0, 3.7), (6.0, 3.2), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))

    // Step 5: checks
    // Diamond for check
    let cx = 6.0
    let cy = 2.7
    line((cx, cy + 0.45), (cx + 1.2, cy), stroke: rgb("#DC2626"), fill: rgb("#FEF2F2"))
    line((cx + 1.2, cy), (cx, cy - 0.45), stroke: rgb("#DC2626"), fill: rgb("#FEF2F2"))
    line((cx, cy - 0.45), (cx - 1.2, cy), stroke: rgb("#DC2626"), fill: rgb("#FEF2F2"))
    line((cx - 1.2, cy), (cx, cy + 0.45), stroke: rgb("#DC2626"), fill: rgb("#FEF2F2"))
    content((cx, cy + 0.1), text(size: 6.5pt, fill: rgb("#DC2626"))[$norm(bold(z))_infinity < gamma_1 - beta$?])
    content((cx, cy - 0.15), text(size: 6.5pt, fill: rgb("#DC2626"))[hints OK?])

    // Reject path (loop back)
    line((cx + 1.25, cy), (cx + 2.5, cy), stroke: (paint: rgb("#DC2626"), thickness: 0.8pt))
    content((cx + 1.9, cy + 0.2), text(size: 6.5pt, fill: rgb("#DC2626"))[no])
    line((cx + 2.5, cy), (cx + 2.5, 7.5), stroke: (paint: rgb("#DC2626"), thickness: 0.8pt, dash: "dashed"))
    line((cx + 2.5, 7.5), (cx + 1.5, 7.5), stroke: (paint: rgb("#DC2626"), thickness: 0.8pt, dash: "dashed"))
    content((cx + 3.0, 5.0), text(size: 6.5pt, fill: rgb("#DC2626"))[$kappa +$$= l$])

    // Accept path
    line((cx, cy - 0.5), (cx, 1.5), stroke: (paint: rgb("#059669"), thickness: 0.8pt))
    content((cx + 0.4, cy - 0.65), text(size: 6.5pt, fill: rgb("#059669"))[yes])

    // Output
    rect((3.5, 0.8), (8.5, 1.5), stroke: rgb("#059669"), radius: 0.08, fill: rgb("#D1FAE5"))
    content((6.0, 1.15), text(size: 8pt, fill: rgb("#059669"), weight: "bold")[$sigma = (tilde(c), bold(z), bold(h))$])
  }),
)

*Geometric view — the mask-challenge-response triangle:*

The key geometric insight is that $bold(z) = bold(y) + c bold(s)_1$ is a vector sum. The mask $bold(y)$ is large and random; the shift $c bold(s)_1$ is small (because both $c$ and $bold(s)_1$ are short). The result $bold(z)$ must land inside the acceptance region.

#figure(
  caption: [Signing geometry in coefficient space. The signer picks a random mask $bold(y)$ (blue) uniformly in the large box $[-gamma_1, gamma_1]^(n l)$. The challenge shifts it by $c bold(s)_1$ (orange, small). If the result $bold(z)$ (green) stays inside the acceptance region $[-gamma_1 + beta, gamma_1 - beta]^(n l)$ (dashed), the signature is accepted. Otherwise the signer restarts.],
  canvas(length: 0.65cm, {
    import draw: *

    // Outer box: mask sampling region [-gamma1, gamma1]
    rect((-5.0, -5.0), (5.0, 5.0), stroke: (paint: rgb("#2563EB"), thickness: 1pt), fill: rgb("#EFF6FF"))
    content((3.8, 5.3), text(size: 7pt, fill: rgb("#2563EB"))[$[-gamma_1, gamma_1]^(n l)$])

    // Inner box: acceptance region [-gamma1+beta, gamma1-beta]
    rect(
      (-4.0, -4.0),
      (4.0, 4.0),
      stroke: (paint: rgb("#059669"), thickness: 1pt, dash: "dashed"),
      fill: rgb("#F0FDF4"),
    )
    content((2.5, 4.3), text(size: 7pt, fill: rgb("#059669"))[$[-gamma_1 + beta, gamma_1 - beta]$])

    // Origin
    circle((0, 0), radius: 0.1, fill: rgb("#111827"))
    content((-0.4, -0.35), text(size: 8pt, weight: "bold")[$bold(0)$])

    // y vector (mask) - accepted case
    set-style(mark: (end: ">", size: 0.12))
    line((0, 0), (1.5, 2.5), stroke: (paint: rgb("#2563EB"), thickness: 1.6pt))
    content((0.6, 2.7), text(size: 8pt, fill: rgb("#2563EB"), weight: "bold")[$bold(y)$])

    // c * s1 shift
    line((1.5, 2.5), (2.2, 3.0), stroke: (paint: rgb("#F59E0B"), thickness: 1.4pt))
    content((2.4, 3.3), text(size: 7pt, fill: rgb("#B45309"))[$c bold(s)_1$])

    // z = y + c*s1 (accepted)
    line((0, 0), (2.2, 3.0), stroke: (paint: rgb("#059669"), thickness: 1.8pt, dash: "densely-dotted"))
    circle((2.2, 3.0), radius: 0.12, fill: rgb("#059669"))
    content((2.9, 3.0), text(size: 8pt, fill: rgb("#059669"), weight: "bold")[$bold(z)$ ✓])

    // y vector - rejected case
    line((0, 0), (-2.5, -3.5), stroke: (paint: rgb("#93C5FD"), thickness: 1.2pt))
    content((-1.8, -3.7), text(size: 7pt, fill: rgb("#93C5FD"))[$bold(y)'$])

    // c * s1 shift for rejected
    line((-2.5, -3.5), (-3.0, -4.2), stroke: (paint: rgb("#FCD34D"), thickness: 1pt))

    // z' rejected (outside inner box)
    circle((-3.0, -4.2), radius: 0.1, fill: rgb("#DC2626"))
    line((-3.2, -4.4), (-2.8, -4.0), stroke: (paint: rgb("#DC2626"), thickness: 1.8pt))
    line((-3.2, -4.0), (-2.8, -4.4), stroke: (paint: rgb("#DC2626"), thickness: 1.8pt))
    content((-3.8, -4.2), text(size: 7pt, fill: rgb("#DC2626"))[$bold(z)'$ ✗])

    // Annotation: beta margin
    set-style(mark: (end: "|", size: 0.08))
    line((5.2, 4.0), (5.2, 5.0), stroke: (paint: rgb("#6B7280"), thickness: 0.6pt))
    content((5.8, 4.5), text(size: 6.5pt, fill: rgb("#6B7280"))[$beta$])
  }),
)

*Why rejection sampling is essential:*

Without rejection, the distribution of $bold(z) = bold(y) + c bold(s)_1$ depends on $bold(s)_1$. An attacker who sees many signatures could statistically recover $bold(s)_1$. Rejection sampling ensures that the *conditional* distribution of $bold(z)$ (given that it is output) is uniform over the acceptance region, independent of $bold(s)_1$.

#figure(
  caption: [Rejection sampling removes secret-key dependence. Left: without rejection, the distribution of $bold(z)$ is centered at $c bold(s)_1$ (leaks the secret). Right: with rejection, only $bold(z)$ values inside the acceptance box are output — the distribution is uniform and independent of $bold(s)_1$.],
  canvas(length: 0.7cm, {
    import draw: *

    // ── Left: without rejection ──
    content((-4.0, 4.5), text(size: 8pt, weight: "bold")[Without rejection])

    // Box
    rect((-7.0, -3.0), (-1.0, 3.5), stroke: rgb("#D1D5DB"), radius: 0.06)

    // Distribution centered at c*s1 (shifted)
    let cx = -3.0
    let cy = 1.0
    circle(
      (cx, cy),
      radius: 2.0,
      stroke: (paint: rgb("#DC2626"), thickness: 0.8pt, dash: "dotted"),
      fill: rgb("#FEE2E2"),
    )
    circle(
      (cx, cy),
      radius: 1.2,
      stroke: (paint: rgb("#DC2626"), thickness: 0.6pt, dash: "dotted"),
      fill: rgb("#FECACA"),
    )
    circle((cx, cy), radius: 0.4, fill: rgb("#F87171"))
    content((cx, cy), text(size: 6pt, fill: white, weight: "bold")[peak])

    // c*s1 label
    set-style(mark: (end: ">", size: 0.08))
    line((-4.0, -0.5), (cx, cy - 0.1), stroke: (paint: rgb("#F59E0B"), thickness: 1pt))
    content((-4.8, -0.5), text(size: 7pt, fill: rgb("#B45309"))[$c bold(s)_1$])

    // Origin
    circle((-4.0, 0.0), radius: 0.08, fill: rgb("#111827"))
    content((-4.4, -0.2), text(size: 7pt)[$bold(0)$])

    // Leak warning
    content((-4.0, -2.5), text(size: 7pt, fill: rgb("#DC2626"), weight: "bold")[leaks $bold(s)_1$!])

    // ── Right: with rejection ──
    content((4.0, 4.5), text(size: 8pt, weight: "bold")[With rejection])

    // Acceptance box
    rect((1.0, -2.5), (7.0, 3.0), stroke: rgb("#059669"), radius: 0.06, fill: rgb("#D1FAE5"))

    // Uniform fill (just the box itself represents uniform)
    content((4.0, 0.25), text(size: 8pt, fill: rgb("#059669"))[uniform])
    content((4.0, -0.15), text(size: 7pt, fill: rgb("#059669"))[density])

    // Several sample z points scattered uniformly
    circle((2.0, 1.5), radius: 0.08, fill: rgb("#059669"))
    circle((5.5, 2.0), radius: 0.08, fill: rgb("#059669"))
    circle((3.0, -1.5), radius: 0.08, fill: rgb("#059669"))
    circle((6.0, -0.5), radius: 0.08, fill: rgb("#059669"))
    circle((1.5, -0.8), radius: 0.08, fill: rgb("#059669"))
    circle((4.5, 1.8), radius: 0.08, fill: rgb("#059669"))
    circle((5.0, -1.8), radius: 0.08, fill: rgb("#059669"))
    circle((2.5, 2.2), radius: 0.08, fill: rgb("#059669"))

    // Rejected points outside (X marks)
    circle((7.5, 1.0), radius: 0.06, fill: rgb("#DC2626"))
    line((7.3, 0.8), (7.7, 1.2), stroke: (paint: rgb("#DC2626"), thickness: 1.2pt))
    line((7.3, 1.2), (7.7, 0.8), stroke: (paint: rgb("#DC2626"), thickness: 1.2pt))

    circle((0.5, 3.5), radius: 0.06, fill: rgb("#DC2626"))
    line((0.3, 3.3), (0.7, 3.7), stroke: (paint: rgb("#DC2626"), thickness: 1.2pt))
    line((0.3, 3.7), (0.7, 3.3), stroke: (paint: rgb("#DC2626"), thickness: 1.2pt))

    // Safe label
    content((4.0, -2.0), text(size: 7pt, fill: rgb("#059669"), weight: "bold")[independent of $bold(s)_1$ ✓])
  }),
)

=== Phase 3: Verification

Verification reconstructs the commitment $bold(w)_1$ from the signature and public key, then checks the hash.

*Step by step (FIPS 204, Algorithm 3 / Algorithm 8):*

+ Reconstruct $bold(A) = "ExpandA"(rho)$ from the public key.
+ Recover the challenge polynomial: $c = "SampleInBall"(tilde(c))$.
+ Compute $bold(A) bold(z) - c bold(t)$ (using NTT for speed).
+ Apply hints: $bold(w)'_1 = "UseHint"(bold(h), bold(A) bold(z) - c bold(t))$.
+ *Check norm*: $norm(bold(z))_infinity < gamma_1 - beta$.
+ *Check hash*: $tilde(c) =^? H(mu || "Encode"(bold(w)'_1))$.

*Why it works — the algebra:*

$
  bold(A) bold(z) - c bold(t) & = bold(A)(bold(y) + c bold(s)_1) - c(bold(A) bold(s)_1 + bold(s)_2) \
                              & = bold(A) bold(y) + c bold(A) bold(s)_1 - c bold(A) bold(s)_1 - c bold(s)_2 \
                              & = bold(A) bold(y) - c bold(s)_2 \
                              & = bold(w) - c bold(s)_2
$

Since $c bold(s)_2$ is short (both $c$ and $bold(s)_2$ are short), the high bits of $bold(A) bold(z) - c bold(t)$ match the high bits of $bold(w)$. The hints $bold(h)$ correct any remaining carry discrepancies, so $bold(w)'_1 = bold(w)_1$ exactly.

#figure(
  caption: [Verification data flow. The verifier uses only public information (pk, $sigma$, message) to recompute $bold(w)'_1$ and check the hash. The hints $bold(h)$ correct rounding errors so that $bold(w)'_1 = bold(w)_1$ exactly.],
  canvas(length: 0.75cm, {
    import draw: *
    set-style(mark: (end: ">", size: 0.1))

    // Inputs
    rect((0.0, 7.0), (3.5, 7.6), stroke: rgb("#7C3AED"), radius: 0.06, fill: rgb("#F5F3FF"))
    content((1.75, 7.3), text(size: 7.5pt, fill: rgb("#7C3AED"))[$"pk" = (rho, bold(t)_1)$])

    rect((4.0, 7.0), (8.0, 7.6), stroke: rgb("#059669"), radius: 0.06, fill: rgb("#ECFDF5"))
    content((6.0, 7.3), text(size: 7.5pt, fill: rgb("#059669"))[$sigma = (tilde(c), bold(z), bold(h))$])

    rect((8.5, 7.0), (11.5, 7.6), stroke: rgb("#6B7280"), radius: 0.06, fill: rgb("#F3F4F6"))
    content((10.0, 7.3), text(size: 7.5pt)[message $M$])

    // Expand A
    line((1.75, 6.95), (1.75, 6.35), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))
    rect((0.0, 5.8), (3.5, 6.35), stroke: rgb("#2563EB"), radius: 0.06, fill: rgb("#EFF6FF"))
    content((1.75, 6.07), text(size: 7.5pt)[$bold(A) = "ExpandA"(rho)$])

    // Recover c
    line((5.0, 6.95), (5.0, 6.35), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))
    rect((3.8, 5.8), (6.5, 6.35), stroke: rgb("#7C3AED"), radius: 0.06, fill: rgb("#F5F3FF"))
    content((5.15, 6.07), text(size: 7.5pt)[$c = "SampleInBall"(tilde(c))$])

    // mu
    line((10.0, 6.95), (10.0, 6.35), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))
    rect((8.5, 5.8), (11.5, 6.35), stroke: rgb("#6B7280"), radius: 0.06, fill: rgb("#F3F4F6"))
    content((10.0, 6.07), text(size: 7.5pt)[$mu = H("tr" || M)$])

    // Compute A*z - c*t
    line((1.75, 5.75), (4.0, 5.0), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))
    line((5.15, 5.75), (5.15, 5.0), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))
    line((6.5, 6.95), (6.0, 5.0), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))
    rect((2.5, 4.4), (7.8, 5.0), stroke: rgb("#111827"), radius: 0.06, fill: rgb("#F9FAFB"))
    content((5.15, 4.7), text(size: 7.5pt)[$bold(A) bold(z) - c bold(t)$ (via NTT)])

    // UseHint
    line((5.15, 4.35), (5.15, 3.75), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))
    line((7.0, 6.95), (7.5, 3.75), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt, dash: "dotted"))
    rect((2.5, 3.15), (7.8, 3.75), stroke: rgb("#F59E0B"), radius: 0.06, fill: rgb("#FFFBEB"))
    content((5.15, 3.45), text(size: 7.5pt)[$bold(w)'_1 = "UseHint"(bold(h), bold(A) bold(z) - c bold(t))$])

    // Two checks
    line((5.15, 3.1), (3.5, 2.4), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))
    line((5.15, 3.1), (8.0, 2.4), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))

    // Norm check
    rect((1.5, 1.8), (5.5, 2.4), stroke: rgb("#DC2626"), radius: 0.06, fill: rgb("#FEF2F2"))
    content((3.5, 2.1), text(size: 7.5pt, fill: rgb("#DC2626"))[$norm(bold(z))_infinity < gamma_1 - beta$ ?])

    // Hash check
    line((10.0, 5.75), (9.5, 2.4), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt, dash: "dotted"))
    rect((6.0, 1.8), (10.5, 2.4), stroke: rgb("#7C3AED"), radius: 0.06, fill: rgb("#F5F3FF"))
    content((8.25, 2.1), text(size: 7.5pt, fill: rgb("#7C3AED"))[$tilde(c) =^? H(mu || bold(w)'_1)$])

    // Final decision
    line((3.5, 1.75), (5.5, 1.1), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))
    line((8.25, 1.75), (5.5, 1.1), stroke: (paint: rgb("#6B7280"), thickness: 0.7pt))
    rect((3.8, 0.5), (7.2, 1.1), stroke: rgb("#059669"), radius: 0.08, fill: rgb("#D1FAE5"))
    content((5.5, 0.8), text(size: 8pt, fill: rgb("#059669"), weight: "bold")[both pass → ACCEPT])
  }),
)

#figure(
  caption: [Verification algebra visualized. The verifier computes $bold(A) bold(z)$ (a lattice point), subtracts $c bold(t)$, and gets $bold(w) - c bold(s)_2$. Since $c bold(s)_2$ is short, the high bits match $bold(w)_1$, and the hash check succeeds.],
  canvas(length: 0.8cm, {
    import draw: *

    // Lattice points (background)
    for x in range(-2, 7) {
      for y in range(-1, 6) {
        let px = x * 1.2
        let py = y * 1.2
        if px >= -1.5 and px <= 7.5 and py >= -0.5 and py <= 6.0 {
          circle((px, py), radius: 0.035, fill: rgb("#E5E7EB"))
        }
      }
    }

    // Origin
    circle((0, 0), radius: 0.06, fill: rgb("#111827"))
    content((-0.3, -0.2), text(size: 7pt)[$bold(0)$])

    // A*z (lattice point)
    let azx = 4.8
    let azy = 4.8
    circle((azx, azy), radius: 0.09, fill: rgb("#2563EB"))
    content((azx + 0.4, azy + 0.25), text(size: 8pt, fill: rgb("#2563EB"), weight: "bold")[$bold(A) bold(z)$])

    // c*t (the vector to subtract)
    set-style(mark: (end: ">", size: 0.1))
    line((azx, azy), (azx - 1.5, azy - 1.2), stroke: (paint: rgb("#DC2626"), thickness: 1.4pt))
    content((azx - 0.3, azy - 0.9), text(size: 7pt, fill: rgb("#DC2626"))[$-c bold(t)$])

    // A*z - c*t = w - c*s2
    let rx = azx - 1.5
    let ry = azy - 1.2
    circle((rx, ry), radius: 0.09, fill: rgb("#F59E0B"))
    content((rx - 1.0, ry + 0.3), text(size: 7pt, fill: rgb("#B45309"))[$bold(w) - c bold(s)_2$])

    // w (the original commitment, nearby)
    let wx = 3.6
    let wy = 3.6
    circle((wx, wy), radius: 0.09, fill: rgb("#059669"))
    content((wx - 0.8, wy - 0.3), text(size: 8pt, fill: rgb("#059669"), weight: "bold")[$bold(w)$])

    // c*s2 is the small gap
    line((rx, ry), (wx, wy), stroke: (paint: rgb("#9CA3AF"), thickness: 0.8pt, dash: "dotted"))
    content((rx + 0.6, ry - 0.3), text(size: 6pt, fill: rgb("#6B7280"))[$c bold(s)_2$ (small)])

    // HighBits annotation
    rect((0.5, 1.5), (3.0, 2.2), stroke: rgb("#7C3AED"), radius: 0.06, fill: rgb("#F5F3FF"))
    content((1.75, 1.85), text(size: 7pt, fill: rgb("#7C3AED"))[HighBits match!])
    line((1.75, 2.25), (wx - 0.1, wy - 0.1), stroke: (paint: rgb("#7C3AED"), thickness: 0.6pt, dash: "dotted"))
    line((1.75, 2.25), (rx + 0.1, ry - 0.1), stroke: (paint: rgb("#7C3AED"), thickness: 0.6pt, dash: "dotted"))

    // Label
    content((5.5, 6.0), text(size: 7pt, fill: rgb("#6B7280"))[lattice $= {bold(A) bold(x) : bold(x) in R_q^l}$])
  }),
)

=== Security: what an attacker faces

#figure(
  caption: [Security reduction tree. Any successful attack on ML-DSA implies an efficient algorithm for either Module-LWE or Module-SIS, both of which reduce to worst-case lattice problems believed to be hard even for quantum computers.],
  canvas(length: 0.8cm, {
    import draw: *
    set-style(mark: (end: ">", size: 0.1))

    // Attacker
    rect((3.5, 5.5), (7.5, 6.3), stroke: rgb("#DC2626"), radius: 0.1, fill: rgb("#FEF2F2"))
    content((5.5, 5.9), text(size: 9pt, fill: rgb("#DC2626"), weight: "bold")[Attacker breaks ML-DSA])

    // Two branches
    line((4.5, 5.45), (2.5, 4.6), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt))
    line((6.5, 5.45), (8.5, 4.6), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt))

    // Key recovery
    rect((0.5, 3.6), (4.5, 4.6), stroke: rgb("#2563EB"), radius: 0.08, fill: rgb("#EFF6FF"))
    content((2.5, 4.25), text(size: 8pt, fill: rgb("#2563EB"), weight: "bold")[Key Recovery])
    content((2.5, 3.85), text(size: 7pt)[recover $bold(s)_1$ from $(bold(A), bold(t))$])

    // Forgery
    rect((6.5, 3.6), (10.5, 4.6), stroke: rgb("#059669"), radius: 0.08, fill: rgb("#ECFDF5"))
    content((8.5, 4.25), text(size: 8pt, fill: rgb("#059669"), weight: "bold")[Signature Forgery])
    content((8.5, 3.85), text(size: 7pt)[find short $bold(z)$: $bold(A) bold(z) approx c bold(t) + bold(w)$])

    // Reductions
    line((2.5, 3.55), (2.5, 2.8), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt, dash: "dashed"))
    content((3.3, 3.2), text(size: 6.5pt, fill: rgb("#6B7280"))[reduces to])
    rect((0.5, 2.0), (4.5, 2.8), stroke: rgb("#F59E0B"), radius: 0.08, fill: rgb("#FFFBEB"))
    content((2.5, 2.4), text(size: 8pt, fill: rgb("#B45309"), weight: "bold")[Module-LWE])

    line((8.5, 3.55), (8.5, 2.8), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt, dash: "dashed"))
    content((9.3, 3.2), text(size: 6.5pt, fill: rgb("#6B7280"))[reduces to])
    rect((6.5, 2.0), (10.5, 2.8), stroke: rgb("#F59E0B"), radius: 0.08, fill: rgb("#FFFBEB"))
    content((8.5, 2.4), text(size: 8pt, fill: rgb("#B45309"), weight: "bold")[Module-SIS])

    // Both reduce to lattice
    line((2.5, 1.95), (5.5, 1.1), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt, dash: "dotted"))
    line((8.5, 1.95), (5.5, 1.1), stroke: (paint: rgb("#6B7280"), thickness: 0.8pt, dash: "dotted"))
    content((4.0, 1.4), text(size: 6.5pt, fill: rgb("#6B7280"))[worst-case])
    content((7.0, 1.4), text(size: 6.5pt, fill: rgb("#6B7280"))[worst-case])

    rect((3.0, 0.3), (8.0, 1.1), stroke: rgb("#7C3AED"), radius: 0.1, fill: rgb("#F5F3FF"))
    content((5.5, 0.7), text(size: 8pt, fill: rgb("#7C3AED"), weight: "bold")[Hard Lattice Problems])
    content((5.5, 0.4), text(size: 6.5pt, fill: rgb("#7C3AED"))[(SVP, CVP in high dimension)])
  }),
)

*In summary:*
- *Key recovery* $arrow.r.double$ solve Module-LWE: given $bold(A)$ and $bold(t) = bold(A) bold(s)_1 + bold(s)_2$, find the short $bold(s)_1$.
- *Forgery* $arrow.r.double$ solve Module-SIS: find a short $bold(z)$ satisfying the linear constraint $bold(A) bold(z) equiv c bold(t) + bold(w) mod q$.
- Both Module-LWE and Module-SIS are at least as hard as worst-case lattice problems in dimension $n k$ (Langlois & Stehlé, 2015).
- No known quantum algorithm provides a significant speedup for these problems.

== Summary

#table(
  columns: (auto, auto, auto),
  align: (left, left, left),
  table.header([*Concept*], [*Role in ML-DSA*], [*Intuition*]),
  [Lattice], [Underlying algebraic structure], [Infinite grid of integer-combination points],
  [SVP / CVP], [Source of computational hardness], [Finding short / close vectors is hard in high dimensions],
  [SIS], [Signature verification], [Short $bold(x)$: $bold(A) bold(x) = bold(0)$ is hard to find],
  [LWE], [Key generation], [$bold(t) = bold(A) bold(s) + bold(e)$ hides $bold(s)$],
  [Module structure], [Efficiency + compact keys], [Polynomial ring gives NTT speedup and smaller representations],
  [Rejection sampling], [Signature security], [Ensures $bold(z)$ leaks nothing about $bold(s)_1$],
)

*Bottom line:* Geometry gives the hardness (short vectors are hard to find). Algebra gives the efficiency (polynomial rings enable NTT). ML-DSA combines both into a practical post-quantum signature scheme.
