# Module Lattice Math and Code Guide

This document explains the math model behind `src/module_lattice/` and how each concept maps to the Rust code.

## 0) Toy-Size Intuition (Small Examples)

Real ML-DSA uses degree 256 and large prime `q = 8_380_417`. For intuition, use tiny numbers first.

### A) Field example (`F_17`)

- `5 + 14 = 19 = 2 (mod 17)`
- `5 - 9 = -4 = 13 (mod 17)`
- `5 * 7 = 35 = 1 (mod 17)`

This is exactly what `Elem<F>` does in code after reduction.

### B) Polynomial coefficient operations

Code stores 256 coefficients, but imagine 8 coefficients to see it clearly:

- `p = [1, 2, 0, 0, 0, 0, 0, 0]`
- `r = [3, 4, 0, 0, 0, 0, 0, 0]`

Then element-wise operations are:

- `p + r = [4, 6, 0, 0, 0, 0, 0, 0]`
- `p - r = [15, 15, 0, 0, 0, 0, 0, 0]` over `F_17`
- `3 * p = [3, 6, 0, 0, 0, 0, 0, 0]`

This matches `Polynomial<F>` `+`, `-`, and scalar `Elem<F> * Polynomial<F>`.

### C) Vector and matrix intuition

Take length-2 vectors over polynomials:

- `v = [p0, p1]`, `w = [r0, r1]`
- `v + w = [p0 + r0, p1 + r1]`

In NTT domain, dot-product style multiplication is:

- `<v_hat, w_hat> = p0_hat * r0_hat + p1_hat * r1_hat`

That is what `&NttVector * &NttVector -> NttPolynomial` computes.

### D) Encoding example (4 bits)

Pack 8 small values into 4 bytes:

- input: `[1, 2, 15, 0, 7, 3, 12, 8]`
- pack pairs: `(1,2), (15,0), (7,3), (12,8)`
- bytes: `1 + (2 << 4) = 33`, `15 + (0 << 4) = 15`, `7 + (3 << 4) = 55`, `12 + (8 << 4) = 140`
- encoded: `[33, 15, 55, 140]`

Decode does mask/shift and gets the original values back.

Use this mental model, then scale up to 256 coefficients and scheme parameter sizes.

## 1) Algebraic Objects Used by ML-DSA

ML-DSA works over a prime field and polynomial modules.

- Prime field:

  `F_q = Z / qZ`

- Polynomial ring used by the scheme:

  `R_q = F_q[X] / (X^256 + 1)`

- Vector and matrix modules:

  - `R_q^k` (vectors of `k` polynomials)
  - `R_q^(k x l)` (matrices of polynomials)

In this crate, the shared module-lattice layer mostly defines linear operations on coefficients/vectors and NTT-domain containers. Scheme-specific polynomial multiplication rules are provided downstream.

## 2) Field Arithmetic (`algebra.rs`)

### Field trait

`Field` in `src/module_lattice/algebra.rs` defines:

- integer types (`Int`, `Long`, `LongLong`)
- modulus constants (`Q`, `QL`, `QLL`)
- reduction methods (`small_reduce`, `barrett_reduce`)

### Element operations

For `a, b in F_q`, `Elem<F>` implements:

- addition: `a + b mod q`
- subtraction: `a - b mod q`
- negation: `-a mod q`
- multiplication: `a * b mod q`

The code keeps values in canonical range using reduction after each operation.

### Barrett reduction

For faster modular reduction, the code uses:

- `k = BARRETT_SHIFT`
- `m = floor(2^k / q)`
- `t = floor(x * m / 2^k)`
- `r = x - t * q`

Then one final small correction maps `r` into `[0, q)`.

This is implemented by `Field::barrett_reduce` and generated by `define_field!`.

## 3) Polynomial, Vector, NTT Types (`algebra.rs`)

Main containers:

- `Polynomial<F>`: 256 coefficients (`Array<Elem<F>, U256>`)
- `Vector<F, K>`: `K` polynomials
- `NttPolynomial<F>`: 256-value NTT-domain representation
- `NttVector<F, K>`: vector of NTT polynomials
- `NttMatrix<F, K, L>`: `K x L` matrix in NTT domain

Supported operations include:

- element-wise `+`, `-`, unary `-`
- scalar multiplication by `Elem<F>`
- NTT-domain vector dot products and matrix-vector products

`MultiplyNtt` is intentionally a trait hook. The concrete NTT multiply rule is scheme-specific and implemented in higher-level modules.

## 4) Bit Packing and Unpacking (`encode.rs`)

`encode.rs` implements FIPS-style packing for 256-coefficient polynomials.

For bit width `d`, chunk values `(v_0, ..., v_(t-1))` are packed as:

`x = sum_{j=0}^{t-1} v_j * 2^(d * j)`

Then `x` is emitted in little-endian bytes. Decoding reverses this with:

`v_j = (x >> (d * j)) & (2^d - 1)`

Type-level arithmetic (`typenum`) enforces sizes at compile time:

- `EncodedPolynomialSize<D> = 32 * D` bytes for 256 coefficients
- `EncodedVectorSize<D, K> = K * EncodedPolynomialSize<D>`

The core generic interface is the `Encode<D>` trait, implemented for:

- `Polynomial<F>`
- `Vector<F, K>`
- `NttPolynomial<F>`
- `NttVector<F, K>`

## 5) Utilities (`util.rs`)

`util.rs` provides helpers used by algebra/encoding:

- `Truncate<T>`: safe low-bit truncation between integer widths
- `Flatten`: `[[T; M]; N] -> [T; M*N]`
- `Unflatten`: `[T; M*N] -> [[T; M]; N]` (and reference variant)

These are used to move between vector-of-polynomial encodings and flat byte arrays efficiently.

## 6) Quick Mapping: Math -> Code

- `F_q` element -> `Elem<F>`
- polynomial in `R_q` (coefficient view) -> `Polynomial<F>`
- module vector `R_q^k` -> `Vector<F, K>`
- NTT-domain polynomial -> `NttPolynomial<F>`
- NTT-domain module matrix -> `NttMatrix<F, K, L>`
- bit-pack / bit-unpack -> `Encode<D>::encode` / `Encode<D>::decode`

## 7) Minimal Usage Example

```rust
use crate::define_field;
use crate::module_lattice::algebra::{Elem, Polynomial};
use crate::module_lattice::encode::Encode;
use hybrid_array::typenum::U4;

define_field!(TestField, u32, u64, u128, 17);

let mut coeffs = hybrid_array::Array::default();
coeffs[0] = Elem::<TestField>::new(1);
coeffs[1] = Elem::<TestField>::new(2);
let p = Polynomial::new(coeffs);

let enc = Encode::<U4>::encode(&p);
let dec: Polynomial<TestField> = Encode::<U4>::decode(&enc);
assert_eq!(p, dec);
```

This mirrors the round-trip property relied on by ML-DSA key/signature encodings.
